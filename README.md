A Work in Progress
------------------

I've taken on this framework as a project to test the limits of my skills in complex areas of the language. This framework may become a powerful tool in the next few months, but for the immediate future, don't even bother with it! It'll take me at least a month to hammer down the syntax in a user friendly way. I certainly didn't start this because there aren't enough JS frameworks out there; I'd just like to take on the challenge of building a good one. 

**As of now: 50%** of the syntax defined below is probably what I'll go with.

**Update:** I'm putting this framework on hold to work on the Document functionality shown below as a standalone framework.

Why Use a Framework?
--------------------------------

When developing web apps, the functionality gets complex quickly, both on the client and server side. You end up piling on some much functionality, maintaining and extending the software becomes nearly impossible if you haven't structured properly. Keeping code decoupled, properly-organized, and fully extensible is very time consuming, even with great project management. Without a framework promoting the use of good JS OOP coding patterns, the code can very quickly become a tangled mess!

Introduction to AirJS
---------------------------

Air JS makes web application development more realistic, organized, and clean. It's a command center where you can build the app from the ground up, call on resources that you've already built, and maintain a unified, organized, physical structure to your code.

Air JS facilitates a neat, object oriented, decoupled, "wireless" structure in web application engines and front-ends. 

The lightweight  framework facilitates maintainable code that is:

- structured neatly within an Object Oriented design
- decoupled, through Inversion of Control with Dependency Injection
- wireless via Relational Awareness and The Observer pattern

The framework features some powerful built-in components, allowing you to focus on your own components rather than reinvent the wheel for each new app.

Whether you use the framework to facilitate the production of your functionality from scratch, call on some of the framework's powerful built-in components, or employ some external libraries, Air JS will ensure that it's all done in a structured, maintainable way.

Syntax and Structure with AirJS
-------------------------------------------

**Client:**

Create an instance of AirJS:

    var App = new AirJS();
    
Create a `document object` for your app, to act as your front end control center. All html tags and attributes are supported as objects, and the functionality works precisely as you'd expect it to. Because Air JS prototyping supports the Observer Pattern, any changes made to the objects owned by `document` will reflect on the page:

    App.Document = new document({

        Head: new head({

            title: new title({
            
            	text: "My First Air JS App"
            
            }),
            description: new description({
            
            	text: "This page was generated by the Air JS Document object."
            
            }),
            favicon: new link({

                rel: "icon",
                type: "image/png",
                href: "link.icon"

            }),
            style: new link({

                rel: "stylesheet",
                type: "text/css",
                href: "link.css"

            })

        }),

        Body: new body({

            header: new div({

                class: "header",
                    logo: new div({

                        class: "logo",
                        text: "Logo Text",
                        style: "color: gray"

                    })


            }),
            body: new div({

                class: "app_body",
                image_gallery: new html("modules/gallery.html"),


            }),
            footer: new div({

                title: new h1({

                    class: "map_title",
                    text: "Google Map",
                    style: "color:gray"

                }),
                google_map: new html("<embed code>")

            })

        })

    });
    
You can build different models for the page and call them neatly in the Document object, or traverse through them as the user interacts with the page.

    App.Models.ChatRoom = new model({

        chat_wrapper: new div({

            class: "chat_wrapper",
            // design in progress

        }),

        chat_ad: new html("<embed code>");

    });
    
    App.Models.ChatRoom.insert(Document.Body.body, "within");

And finally, add an engine object to your app:

    App.Engine = new engine({

        Server: new server({


            location: new location({

                url: new URL("www.website.com"),
                IP: new IP("1.2.3.4.5"),
                ports: new portList({

                    app: new defaultPort("8080"),
                    socket: new socketPort("4545")

                }),
                paths: new pathList({

                    app: "App",
                    login: "Login",
                    register: "Register",
                    getData: "Get"

                })

            }),

            auth: new authentication({

                username: new username(App.Client.Username),
                password: new password(App.Client.Password)

            }),

        }),

        Socket: new socketIO({

            open: new socketListener("open", function () {

                App.Document.show(App.Models.ChatRoom, Document.Body.body, "within");

            })

        })

    });

    App.init();
    
Either when you declare the engine object, or through appending it later, you can create your own prototypes with AirJS. By using the AirJS `prototype constructor`, or "prototype prototype", via `new prototype`, you maintain an engine of object oriented components, with their own methods, interfaces, and dependencies, making for very testable, decoupled, clean-looking code. 

    [syntax for example in progress]

**Server:**

[in progress]

The Wireless Nature of Air JS
----------------------------------------

Air JS is named for its light weight and "wireless" nature.
	
Sky JS objects that utilize each-other will dynamically locate and utilize the information "wireless", without the developer having to pass objects and information through parameters.

For example, on the **client side**, you want to create a socketIO connection. To make that connection though, you need to load socket.io, and then make the socket connection the proper IP and socketIO port of your server. The framework has a built-in socketIO blueprint, and a built-in server blueprint, so it's a great example of this wireless behavior in action.

Within an engine object, `App.Engine = new engine({ /* here */ })` lets create a new `server object`, as a container for server information:
    

    Server: new server({

        location: new location({

            url  : new URL("www.website.com"),
            IP   : new IP("1.2.3.4.5"),
            ports: new portList({

                app   : new defaultPort("8080"),
                socket: new socketPort("4545")

            }),
            paths: new pathList({

                app     : "App",
                login   : "Login",
                register: "Register",
                getData : "Get"

            })

        }),

        auth: new authentication({

            username: new username(App.Client.Username),
            password: new password(App.Client.Password)

        })

    }),

Now, all we have to do is add a `socketIO object`, to get our socket connection running:

    "Socket": new socketIO({

        open: new socketListener("open", function () {

            // handle event

        })

    })
    
Since Air JS lists the `socketPort prototype` as a dependency / related component within the `socketIO prototype`, AirJS knows to search for it in the `engine`'s scope, and utilize the first one that it finds. If for some reason there were two `server objects`, you would pass in the object or its parent, and Air JS would search / use that specific object.

So how does it work?

When creating a new component in your app, Air JS facilitates the listing of dependencies to fill parameters. For example, if you create a new blueprint `Car`, and list `carDoor` as a dependency, when creating a new `Car` object, Air JS will search the appropriate scope for a `carDoor` and utilize it without it having to be passed in as a parameter. 

   Blueprints : {

        Car : new prototype({

        

        })

    }

If you want to be specific about which `carDoor` the car uses, then it can be passed as a parameter.

The Built-In Components
---------------------------------------------

**Client-Side:**

[in progress]

**Node:**

[in progress]

**Default:**

[in progress]

User Component Facilitation
--------------------------------------------------

[in progress]

Air JS's Facilitated Patterns
-----------------------------
	
**The Observer Pattern:**
	
*The Observer is a design pattern where an object (known as a subject) maintains a list of objects depending on it (observers), automatically notifying them of any changes to state.*
		
**Dependency Injection:**
	
*Dependency injection is a software design pattern that implements inversion of control and allows a program design to follow the dependency inversion principle.*
	
